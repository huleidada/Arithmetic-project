from scipy.optimize import linprog

# 目标函数的系数
# 目标函数：Maximize Z = 3x1 + 5x2
# 为了与 `linprog` 兼容，linprog 默认求解最小化问题，
# 所以目标函数需要取负值：Maximize Z -> Minimize -Z
# c = [-3, -5] 是目标函数的系数 (c1 = -3, c2 = -5)
c = [-3, -5]

# 约束条件的系数矩阵 A 和右侧常数项 b
# 约束条件：
# x1 + 2x2 <= 6
# 4x1 + x2 <= 8
# 这些约束的系数矩阵 A 为：
# A = [[1, 2], [4, 1]]
# 右侧常数项 b 为：[6, 8]
A = [[1, 2], [4, 1]]
b = [6, 8]

# 变量的边界条件 (x1 >= 0, x2 >= 0)
# 这是标准的非负约束：x1, x2 >= 0
# 变量 x1 和 x2 的范围：[0, None]，表示 x1 和 x2 都是非负的
x0_bounds = (0, None)  # x1 >= 0
x1_bounds = (0, None)  # x2 >= 0

# 调用线性规划求解器
# 通过 `linprog` 求解最小化问题，得到最优解
# 线性规划的标准形式是：
# 最大化 Z = c1*x1 + c2*x2
# 约束条件：
# A1*x1 + A2*x2 <= b1
# A3*x1 + A4*x2 <= b2
# 以及 x1, x2 >= 0
res = linprog(c, A_ub=A, b_ub=b, bounds=[x0_bounds, x1_bounds], method='simplex')

# 输出结果
# 最优解对应的目标函数值为 -res.fun，因为我们最初取了负号来将最大化问题转为最小化问题
# 还原回最优的目标函数值 (即 Z = -(-Z))
print("Optimal value:", -res.fun)  # 记得取负值，因为我们最初加了负号
print("x1:", res.x[0])  # x1 的最优解
print("x2:", res.x[1])  # x2 的最优解

# 公式详解：

# 1. 目标函数：
# 我们要最大化目标函数 Z = 3x1 + 5x2。为了与 `linprog` 兼容，
# linprog 默认求解的是最小化问题，所以我们将目标函数取负数来转化为最小化问题，
# 即：Maximize Z = 3x1 + 5x2 -> Minimize -Z = -3x1 - 5x2
# 在代码中，目标函数的系数为：c = [-3, -5]，表示我们要求解的目标是最小化 -3x1 - 5x2。

# 2. 约束条件：
# 约束条件的线性形式为：
# x1 + 2x2 <= 6 (约束1)
# 4x1 + x2 <= 8 (约束2)
# 这些约束条件的系数矩阵 A 为：A = [[1, 2], [4, 1]]，
# 右侧常数项 b 为：[6, 8]，即 A1*x1 + A2*x2 <= b1 和 A3*x1 + A4*x2 <= b2。
# 这些约束条件在 `linprog` 中通过 `A_ub` 和 `b_ub` 参数传递。

# 3. 非负约束：
# 决策变量 x1 和 x2 必须是非负的，即 x1, x2 >= 0，
# 这是线性规划中的标准非负约束。在 `linprog` 中，通过 `bounds` 参数设置：
# x0_bounds = (0, None)，表示 x1 >= 0；
# x1_bounds = (0, None)，表示 x2 >= 0。

# 4. 线性规划的标准形式：
# 线性规划的标准数学形式为：
# 最大化 Z = c1*x1 + c2*x2
# 约束条件：
# A1*x1 + A2*x2 <= b1
# A3*x1 + A4*x2 <= b2
# 非负约束：x1, x2 >= 0
# 在代码中，通过 `linprog` 求解最小化问题，并找到最优解。

# 5. 最优解：
# `res.fun` 存储了最小化目标函数的值，但由于我们将目标函数转化为了最小化问题，
# 因此需要取负值来得到最大化目标函数的最优解。即 `-res.fun` 是实际的最优解。
# 同时，`res.x` 存储了最优解对应的 x1 和 x2 的值。

